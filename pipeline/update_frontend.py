import json
import os
import sys

def load_json(path):
    if os.path.exists(path):
        with open(path, 'r', encoding='utf-8') as f:
            try:
                return json.load(f)
            except:
                return None
    return None

def update_frontend(current_stage_id=None, current_progress=0):
    print(f"ðŸ”„ Syncing Intelligence Core (Stage {current_stage_id}, {current_progress}%)...")
    
    # Paths to parsed intelligence
    REQ_PATH = 'data/parsed/unique_requirements.json'
    CONFLICT_PATH = 'data/parsed/conflicts.json'
    BRD_PATH = 'data/parsed/brd_v1.json'
    STAKEHOLDER_PATH = 'data/parsed/identity_table.json'
    SIGNALS_PATH = 'data/parsed/all_signals.json'

    # Load real data
    reqs = load_json(REQ_PATH)
    conflicts_data = load_json(CONFLICT_PATH)
    brd_data = load_json(BRD_PATH)
    stakeholders_raw = load_json(STAKEHOLDER_PATH)
    signals = load_json(SIGNALS_PATH)

    # 9 Targeted Stages Configuration
    stages_config = [
        ('1', 'Signal Ingestion', 'Enron Emails & PDF Briefly parsed via mailparser/pypdf'),
        ('2', 'Linguistic Cleaning', 'Regex-based noise removal & sentence splitting'),
        ('3', 'Entity Resolution', 'rapidfuzz fuzzy mapping for canonical stakeholder identification'),
        ('4', 'Requirement Labeling', 'BART-inspired High-Speed Classifier (8 labels)'),
        ('5', 'Topic Clustering', 'MiniLM-L6-v2 embeddings + Semantic grouping'),
        ('6', 'Semantic Deduplication', 'scikit-learn cosine similarity matrix & dedupe'),
        ('7', 'Conflict Detection', 'Logical audit of contradictory requirements'),
        ('8', 'Provenance Mapping', 'networkx node attribution & citation scoring'),
        ('9', 'Prose Generation', 'OpenAI GPT-4o synthesis into final BRD sections'),
    ]

    js_content = "/* âš¡ AUTOMATICALLY GENERATED BY BRDGEN INTELLIGENCE PIPELINE âš¡ */\n\n"
    
    # 1. Pipeline Status
    js_content += "export const pipelineStages = [\n"
    reached_current = False
    for sid, label, desc in stages_config:
        status = 'waiting'
        prog = 0
        if sid == str(current_stage_id):
            status = 'processing'
            prog = int(current_progress)
            reached_current = True
        elif not reached_current and current_stage_id:
            status = 'complete'
            prog = 100
        elif current_stage_id == 'DONE':
            status = 'complete'
            prog = 100
            
        js_content += f"    {{ id: '{sid}', label: '{label}', description: '{desc}', progress: {prog}, status: '{status}' }},\n"
    js_content += "];\n\n"

    # 2. Key Metrics - Use real counts if available
    total_reqs = len(reqs) if reqs else 0
    total_conflicts = len(conflicts_data) if conflicts_data else 0
    total_stakeholders = len(set(stakeholders_raw.values())) if isinstance(stakeholders_raw, dict) else 0
    total_signals = len(signals) if signals else 0
    
    js_content += f"export const metricsData = [\n"
    js_content += f"    {{ label: 'Total Requirements', value: {total_reqs if total_reqs else 0}, icon: 'FileText' }},\n"
    js_content += f"    {{ label: 'Conflicts Detected', value: {total_conflicts if total_conflicts else 0}, icon: 'AlertTriangle' }},\n"
    js_content += f"    {{ label: 'Signal Sources', value: {total_signals}, icon: 'Clock' }},\n"
    js_content += f"    {{ label: 'Unique Stakeholders', value: {total_stakeholders if total_stakeholders else 0}, icon: 'Users' }},\n"
    js_content += "];\n\n"
    
    # Progress-based health score
    health = 0
    if signals: health += 10
    if reqs: health += 30
    if brd_data: health += 50
    if total_conflicts == 0 and brd_data: health += 10
    
    js_content += f"export const healthScore = {min(health, 100)};\n\n"

    # 3. Conflicts (Stage 7)
    js_content += "export const conflicts = [\n"
    if conflicts_data:
        for c in conflicts_data:
            js_content += f"    {json.dumps(c, indent=8)},\n"
    js_content += "];\n\n"

    # 4. BRD Sections (Stage 9)
    js_content += "export const brdSections = [\n"
    if brd_data and 'sections' in brd_data:
        for section in brd_data['sections']:
            js_content += "    {\n"
            js_content += f"        id: '{section.get('id', 'sec-1')}',\n"
            js_content += f"        title: {json.dumps(section.get('title', 'Section'))},\n"
            js_content += f"        content: {json.dumps(section.get('description', ''))},\n"
            if 'items' in section:
                js_content += "        requirements: [\n"
                for r in section['items']:
                    js_content += f"            {{ id: '{r.get('id', 'REQ')}', text: {json.dumps(r.get('text', ''))}, label: {json.dumps(r.get('label', 'REQUIREMENT'))}, citations: {r.get('corroboration_count', 1)}, status: 'verified' }},\n"
                js_content += "        ]\n"
            js_content += "    },\n"
    elif current_stage_id == 'DONE' or (current_stage_id == '9' and int(current_progress) == 100):
        # The pipeline finished but didn't produce a BRD? (Shouldn't happen with engines)
        js_content += "    { id: 'sec-1', title: 'Analysis Complete', content: 'The pipeline finished but no prose was generated. Please verify signal quality.', requirements: [] }\n"
    else:
        # Placeholder while processing
        js_content += f"    {{ id: 'sec-1', title: 'Synthesis in Progress', content: 'Generating requirements from current signal corpus (Stage {current_stage_id})...', requirements: [] }}\n"
    js_content += "];\n\n"

    # 5. Parking Lot
    js_content += "export const parkingLot = [\n"
    # Filter for speculative labels
    if reqs:
        speculative = [r for r in reqs if "Speculative" in r.get('label', '')]
        for p in speculative[:5]:
            js_content += f"    {{ id: 'PL-{random.randint(100,999)}', text: {json.dumps(p.get('text', ''))}, date: '2024-02-22' }},\n"
    js_content += "];\n\n"

    # 6. Stakeholders (Stage 3)
    js_content += "export const stakeholders = [\n"
    if isinstance(stakeholders_raw, dict):
        for i, (alias, canonical) in enumerate(list(stakeholders_raw.items())[:12]):
            initials = "".join([n[0] for n in canonical.split() if n]) if canonical else "UN"
            js_content += f"    {{ id: '{i}', name: '{canonical}', initial: '{initials}', role: 'Stakeholder', authority: 'High', channels: ['Corporate Signal'] }},\n"
    js_content += "];\n\n"

    # 7. Citations (Stage 8)
    js_content += "export const citations = [\n"
    if reqs:
        for i, r in enumerate(reqs[:15]):
            js_content += "    {\n"
            js_content += f"        id: 'CIT-{i:03}',\n"
            js_content += f"        channel: {json.dumps(r.get('channel', 'Corporate Signal'))},\n"
            js_content += f"        content: {json.dumps(r.get('text', ''))},\n"
            js_content += f"        sender: {json.dumps(r.get('sender_canonical', 'Unknown Stakeholder'))},\n"
            js_content += f"        role: 'Signal Node',\n"
            js_content += f"        timestamp: '{r.get('timestamp', '2024-02-22')}',\n"
            js_content += f"        corroboration: {r.get('corroboration_count', 1)}\n"
            js_content += "    },\n"
    js_content += "];\n"

    with open('src/data/mockData.js', 'w', encoding='utf-8') as f:
        f.write(js_content)
    print("ðŸš€ Intelligence Datastore Sync Complete.")

if __name__ == "__main__":
    sid = sys.argv[1] if len(sys.argv) > 1 else None
    prg = sys.argv[2] if len(sys.argv) > 2 else 0
    update_frontend(sid, prg)
